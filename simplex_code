import numpy as np


def basic_nbasic_indexes(zvector: np.ndarray, constraints: np.ndarray):
    # zvector:     [1, 2, 3, 0]
    # constraints: [2, 4, 9, 1]
    # -> basic_indexes = [3]
    basic_indexes = np.array(
        [ind for ind in range(constraints.shape[1]) if len(np.nonzero(zvector[ind] + constraints[:, ind])[0]) == 1])
    if constraints.shape[0] != len(basic_indexes):
        raise "Not applicable"
    non_basic_indexes = np.array([x for x in range(constraints.shape[1]) if x not in basic_indexes])
    C_vector = np.array([0 for x in range(len(basic_indexes))])
    return basic_indexes, non_basic_indexes, C_vector


def simplex_method(zvector: np.ndarray,
                   constraints: np.ndarray,
                   bvector: np.ndarray,
                   basic_indexes: np.ndarray,
                   non_basic_indexes: np.ndarray,
                   C_vector: np.ndarray,
                   maximize=True):
    best = 0
    while True:
        B_matrix = np.array([[constraints[row, ind] for ind in basic_indexes] for row in range(constraints.shape[0])])
        left_out_matrix = np.array(
            [[constraints[row, ind] for ind in non_basic_indexes] for row in range(constraints.shape[0])])
        inv_B_matrix = np.linalg.inv(B_matrix)
        X_b = inv_B_matrix.dot(bvector)
        best = C_vector.dot(X_b)
        entering_coefs = C_vector.dot(inv_B_matrix).dot(left_out_matrix) - np.array(
            [zvector[ind] for ind in non_basic_indexes])
        # entering vector represents the non-basic variable
        # index in entering_coefs maps to non_basic_indexes index
        # So, we can take the non-basic variable's index from non_basic_indexes, using the same entering_index
        entering_index = np.argmin(entering_coefs)
        entering_value = entering_coefs[entering_index]
        if entering_value >= 0:
            break
        # To find the leaving vector we will have to perform element wise division of X_{B_i} by V_i^{-1} P_{ent}
        divisors = inv_B_matrix.dot(left_out_matrix[:, entering_index])
        coefficients = np.divide(X_b, divisors)
        leaving_index = np.where(coefficients > 0, coefficients, np.inf).argmin()
        C_vector[leaving_index] = zvector[non_basic_indexes[entering_index]]
        # Swap the entering index for non-basic variable with leaving index for basic variable
        temp = non_basic_indexes[entering_index]
        non_basic_indexes[entering_index] = basic_indexes[leaving_index]
        basic_indexes[leaving_index] = temp
    return best


zvector = np.array([9, 10, 16, 0, 0, 0])

PsMatrix = np.array([[18, 15, 12, 1, 0, 0],
                     [6, 4, 8, 0, 1, 0],
                     [5, 3, 3, 0, 0, 1]])
bvector = np.array([360, 192, 180])

print(simplex_method(zvector, PsMatrix, bvector, *basic_nbasic_indexes(zvector, PsMatrix)))
